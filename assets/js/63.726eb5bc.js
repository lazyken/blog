(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{424:function(e,_,v){"use strict";v.r(_);var t=v(45),r=Object(t.a)({},(function(){var e=this,_=e.$createElement,v=e._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"http-资源优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-资源优化"}},[e._v("#")]),e._v(" HTTP 资源优化")]),e._v(" "),v("p",[e._v("在"),v("strong",[e._v("开篇")]),e._v("中提到涉及网络层的有：")]),e._v(" "),v("ul",[v("li",[e._v("DNS 解析")]),e._v(" "),v("li",[e._v("TCP 连接")]),e._v(" "),v("li",[e._v("HTTP 请求/响应")])]),e._v(" "),v("p",[e._v("对于 DNS 解析和 TCP 连接两个步骤，前端可以做的努力相对有限，下面直接从 HTTP 开始：")]),e._v(" "),v("p",[v("strong",[e._v("HTTP 优化有两个大的方向：")]),e._v("\n1、减少请求次数和 2、减少单次请求所花费的时间")]),e._v(" "),v("h2",{attrs:{id:"_1、减少请求次数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、减少请求次数"}},[e._v("#")]),e._v(" 1、减少请求次数")]),e._v(" "),v("h3",{attrs:{id:"_1-1-资源合并"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-资源合并"}},[e._v("#")]),e._v(" 1.1 资源合并")]),e._v(" "),v("h4",{attrs:{id:"雪碧图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#雪碧图"}},[e._v("#")]),e._v(" 雪碧图")]),e._v(" "),v("p",[e._v("雪碧图是将多个小图标合并在一张图中，从而减少图片资源请求数量的一种优化方案。")]),e._v(" "),v("h3",{attrs:{id:"_1-2-图片-base64"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-图片-base64"}},[e._v("#")]),e._v(" 1.2 图片 Base64")]),e._v(" "),v("p",[e._v("Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。")]),e._v(" "),v("h3",{attrs:{id:"_1-3-按需加载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-按需加载"}},[e._v("#")]),e._v(" 1.3 按需加载")]),e._v(" "),v("p",[e._v("引用 "),v("a",{attrs:{href:"https://v4.webpack.js.org/guides/lazy-loading/",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack 对按需加载的解释"),v("OutboundLink")],1),e._v("：")]),e._v(" "),v("blockquote",[v("p",[e._v("按需加载或者懒加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。")])]),e._v(" "),v("p",[e._v("总结一下常见的按需加载场景有如下几种：")]),e._v(" "),v("ul",[v("li",[e._v("框架中的懒加载\n"),v("ul",[v("li",[e._v("vue 的异步组件")]),e._v(" "),v("li",[e._v("vue 路由懒加载")]),e._v(" "),v("li",[e._v("react 中的 "),v("code",[e._v("import()")]),e._v("、"),v("code",[e._v("React.lazy")]),e._v("、基于路由的代码分割等")])])]),e._v(" "),v("li",[e._v("webpack 的按需加载")]),e._v(" "),v("li",[e._v("图片懒加载")])]),e._v(" "),v("p",[e._v("详情请看专题："),v("RouterLink",{attrs:{to:"/front-end/09.专题系列/03.按需加载.html"}},[e._v("按需加载")])],1),e._v(" "),v("h2",{attrs:{id:"_2、减少单次请求所花费的时间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、减少单次请求所花费的时间"}},[e._v("#")]),e._v(" 2、减少单次请求所花费的时间")]),e._v(" "),v("h3",{attrs:{id:"_2-1-压缩代码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-压缩代码"}},[e._v("#")]),e._v(" 2.1 压缩代码：")]),e._v(" "),v("p",[v("code",[e._v("Tree-Shaking")]),e._v(","),v("code",[e._v("uglifyjs-webpack-plugin")]),e._v("/"),v("code",[e._v("terser-webpack-plugin")]),e._v(" 压缩，Gzip 压缩，")]),e._v(" "),v("h4",{attrs:{id:"tree-shaking"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking"}},[e._v("#")]),e._v(" Tree-Shaking")]),e._v(" "),v("p",[e._v("tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup。")]),e._v(" "),v("p",[e._v('新的 webpack 4 正式版本，扩展了这个检测能力，通过 package.json 的 "sideEffects" 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 "pure(纯的 ES2015 模块)"，由此可以安全地删除文件中未使用的部分。')]),e._v(" "),v("p",[e._v("webpack 打包过程中，对 ES2015 模块代码能够进行 "),v("code",[e._v("tree-shaking")]),e._v("，减少无用代码缩小项目体积大小，起到优化项目的作用。"),v("br"),e._v(" "),v("RouterLink",{attrs:{to:"/front-end/09.专题系列/05.Tree-Shaking.html"}},[e._v("专题：tree-shaking")])],1),e._v(" "),v("h4",{attrs:{id:"uglifyjs-webpack-plugin-terser-webpack-plugin"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#uglifyjs-webpack-plugin-terser-webpack-plugin"}},[e._v("#")]),e._v(" uglifyjs-webpack-plugin/terser-webpack-plugin")]),e._v(" "),v("p",[v("code",[e._v("uglifyjs-webpack-plugin")]),e._v(" 使用 "),v("code",[e._v("uglify-js")]),e._v(" 来压缩 JavaScript.")]),e._v(" "),v("blockquote",[v("p",[e._v("http://lisperator.net/uglifyjs/")]),e._v(" "),v("p",[v("code",[e._v("UglifyJS")]),e._v(" 是用 JavaScript 编写的 JavaScript 压缩器。 它还包含一些可以利用 JavaScript 代码做一些自动化工作的工具:")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("parser")]),e._v("：代码解析器，从 JavaScript 代码生成抽象语法树(AST)的解析器。")]),e._v(" "),v("li",[v("code",[e._v("code generator")]),e._v("：代码生成器，从 AST 输出 JavaScript 代码的代码生成器，也提供了获取"),v("code",[e._v("source map")]),e._v("的选项。")]),e._v(" "),v("li",[v("code",[e._v("compressor (optimizer)")]),e._v("：代码压缩工具(优化工具)，它使用"),v("code",[e._v("transformer API")]),e._v("将 AST 优化为更小的 AST。")]),e._v(" "),v("li",[v("code",[e._v("mangler")]),e._v("：混淆器，将局部变量的名称(通常地)简化为单个字母。")]),e._v(" "),v("li",[v("code",[e._v("scope analyzer")]),e._v("：作用域解析，通过变量在何处被引用或定义等信息来增强 AST 的工具。")]),e._v(" "),v("li",[v("code",[e._v("tree walker")]),e._v("：一个简单的 API，允许您在 AST 中的每个节点上执行操作.")]),e._v(" "),v("li",[v("code",[e._v("tree transformer")]),e._v("：另一个用于转换树的 API。")])])]),e._v(" "),v("p",[e._v("webpack 在 "),v("code",[e._v("v4.26.0")]),e._v(" 将默认的压缩插件从 "),v("code",[e._v("uglifyjs-webpack-plugin")]),e._v(" 改成 "),v("code",[e._v("teaser-webpack-plugin")]),e._v("。"),v("br"),e._v(" "),v("a",{attrs:{href:"https://github.com/webpack/webpack/releases?after=v4.26.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/webpack/webpack/releases?after=v4.26.1"),v("OutboundLink")],1),e._v("\n原因是："),v("code",[e._v("uglifyjs-webpack-plugin")]),e._v(" 使用的 "),v("code",[e._v("uglify-es")]),e._v(" 已经不再被维护而且 "),v("code",[e._v("uglify-js")]),e._v(" 不支持 "),v("code",[e._v("ES6+")]),e._v("，取而代之的是一个名为 "),v("code",[e._v("terser")]),e._v(" 的分支。"),v("code",[e._v("terser")]),e._v(" 分支大部分地保持了 "),v("code",[e._v("uglify-es")]),e._v(" 和 "),v("code",[e._v("uglify-js@3")]),e._v(" 的 API 和 CLI 的兼容性。所以 webpack 官方放弃了使用 "),v("code",[e._v("uglifyjs-webpack-plugin")]),e._v("，建议使用 "),v("code",[e._v("terser-webpack-plugin")]),e._v("。"),v("br"),e._v(" "),v("a",{attrs:{href:"https://github.com/terser-js/terser",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/terser-js/terser"),v("OutboundLink")],1)]),e._v(" "),v("h3",{attrs:{id:"_2-2-抽离公共代码-commonschunkplugin-splitchunksplugin"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-抽离公共代码-commonschunkplugin-splitchunksplugin"}},[e._v("#")]),e._v(" 2.2 抽离公共代码：CommonsChunkPlugin/SplitChunksPlugin")]),e._v(" "),v("p",[e._v("webpack 的 "),v("code",[e._v("CommonsChunkPlugin")]),e._v(" 插件：通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，以便存到缓存中供后续使用。这样后续新加载的页面也使用到公共模块时可以直接从缓存中读取，反之，新的文件本身也要包含所需要的公共模块的代码，体积变大。因此使用 "),v("code",[e._v("CommonsChunkPlugin")]),e._v("，对于新页面来说可以减小体积，请求时也就减少请求的时间了。")]),e._v(" "),v("p",[e._v("最初，chunks（及其内部导入的模块）是通过内部的 Webpack 依赖图中的父子关系连接的。 "),v("code",[e._v("CommonsChunkPlugin")]),e._v("用于避免重复的依赖关系，但是无法进行进一步的优化。"),v("br"),e._v("\n从 "),v("code",[e._v("webpack v4")]),e._v(" 开始，"),v("code",[e._v("CommonsChunkPlugin")]),e._v(" 被删除，转而使用了 "),v("code",[e._v("optimization.splitChunks")]),e._v("。")]),e._v(" "),v("blockquote",[v("p",[v("strong",[e._v("optimization.splitChunks 默认配置")]),v("br"),e._v("\n开箱即用的 "),v("code",[e._v("SplitChunksPlugin")]),e._v(" 应该适合大多数用户。"),v("br"),e._v("\n默认情况下，它仅影响按需加载的 chunks，因为更改初始 chunks 会影响运行项目的 HTML 文件应包含的 script。"),v("br"),e._v("\nwebpack 将根据以下条件自动分割 chunks：")]),e._v(" "),v("ul",[v("li",[e._v("可以共享新的 chunks，或者来自 "),v("code",[e._v("node_modules")]),e._v(" 文件夹的模块")]),e._v(" "),v("li",[e._v("新的 chunks 将大于 30kb（在 "),v("code",[e._v("min+gz")]),e._v(" 之前）")]),e._v(" "),v("li",[e._v("按需加载 chunks 时的并行请求的最大数量将小于或等于 5")]),e._v(" "),v("li",[e._v("初始页面加载时并行请求的最大数量将小于或等于 3")])])]),e._v(" "),v("p",[e._v("当试图满足最后两个条件时，最好使用较大的 chunks。")])])}),[],!1,null,null,null);_.default=r.exports}}]);
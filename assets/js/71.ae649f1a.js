(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{431:function(r,t,e){"use strict";e.r(t);var _=e(45),v=Object(_.a)({},(function(){var r=this,t=r.$createElement,e=r._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h1",{attrs:{id:"浏览器渲染机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染机制"}},[r._v("#")]),r._v(" 浏览器渲染机制")]),r._v(" "),e("blockquote",[e("p",[r._v("本文参考以下文章："),e("br"),r._v(" "),e("a",{attrs:{href:"http://47.98.159.95/my_blog/blogs/browser/browser-render/002.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("从输入 URL 到页面呈现发生了什么？——解析算法篇"),e("OutboundLink")],1),e("br"),r._v(" "),e("a",{attrs:{href:"http://47.98.159.95/my_blog/blogs/browser/browser-render/003.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("从输入 URL 到页面呈现发生了什么？——渲染过程篇"),e("OutboundLink")],1),e("br"),r._v(" "),e("a",{attrs:{href:"https://juejin.cn/book/6844733750048210957",target:"_blank",rel:"noopener noreferrer"}},[r._v("前端性能优化原理与实践"),e("OutboundLink")],1)])]),r._v(" "),e("h1",{attrs:{id:"什么是浏览器渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是浏览器渲染"}},[r._v("#")]),r._v(" 什么是浏览器渲染")]),r._v(" "),e("p",[r._v("通过网络请求到资源后，浏览器的渲染进程会处理 HTML、CSS、JS、图片等资源，把他们解析为可显示、可交互的页面。这一过程就是浏览器渲染阶段。")]),r._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/9/27/16618c7f0cb0768a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"浏览器渲染"}}),e("br"),r._v("\n从整体上来说，"),e("code",[r._v("HTML/CSS/JS资源")]),r._v(" 经过"),e("code",[r._v("浏览器内核")]),r._v("解析和渲染后最终形成了屏幕上的"),e("code",[r._v("图像")]),r._v("。\n其中我们最需要了解的就是内核中以下这些模块：")]),r._v(" "),e("ul",[e("li",[e("strong",[r._v("HTML 解释器")]),r._v("：将 HTML 文档经过词法分析输出 DOM 树。\n在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。")]),r._v(" "),e("li",[e("strong",[r._v("CSS 解释器")]),r._v("：解析 CSS 文档，生成样式规则。\n浏览器将识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）。")]),r._v(" "),e("li",[e("strong",[r._v("图层布局计算模块")]),r._v("：布局计算每个对象的精确位置和大小。\n页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。")]),r._v(" "),e("li",[e("strong",[r._v("视图绘制模块")]),r._v("：进行具体节点的图像绘制，将像素渲染到屏幕上。\n在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。")]),r._v(" "),e("li",[e("strong",[r._v("JavaScript 引擎")]),r._v("：编译执行 JavaScript 代码。")])]),r._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/9/27/16618c829b879f35?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"解析和渲染的几个阶段"}})]),r._v(" "),e("h1",{attrs:{id:"解析和渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解析和渲染"}},[r._v("#")]),r._v(" 解析和渲染")]),r._v(" "),e("p",[r._v("浏览器将 HTML 文件渲染到屏幕上主要分为 2 步："),e("strong",[r._v("解析")]),r._v("和"),e("strong",[r._v("渲染")])]),r._v(" "),e("h2",{attrs:{id:"解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解析"}},[r._v("#")]),r._v(" 解析")]),r._v(" "),e("p",[r._v("解析 HTML 主要分为 3 几个步骤：")]),r._v(" "),e("ul",[e("li",[r._v("构建 "),e("code",[r._v("DOM")]),r._v(" 树")]),r._v(" "),e("li",[e("code",[r._v("样式")]),r._v("计算")]),r._v(" "),e("li",[r._v("生成"),e("code",[r._v("布局树")]),r._v("("),e("code",[r._v("Layout Tree")]),r._v(")")])]),r._v(" "),e("p",[r._v("解析就是浏览器读取 HTML 文本文件，根据 HTML 标签和内容生成一个对象类型的数据，称之为 "),e("code",[r._v("DOM树")]),r._v(" ，它是一个「多叉树的数据结构」；根据 CSS 样式也生成一个结构化的对象即 styleSheets，这里我们称做 "),e("code",[r._v("DOM样式")]),r._v("；最后浏览器将"),e("code",[r._v("DOM树")]),r._v("和 "),e("code",[r._v("DOM样式")]),r._v(" 结合起来，通过布局系统确定元素的位置，生成一个 "),e("code",[r._v("布局树")]),r._v(" (Layout Tree)。")]),r._v(" "),e("h3",{attrs:{id:"解析-html-构建-dom-树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解析-html-构建-dom-树"}},[r._v("#")]),r._v(" 解析 HTML，构建 DOM 树")]),r._v(" "),e("p",[r._v("解析的第一步是构建 "),e("code",[r._v("DOM树")]),r._v("。在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。")]),r._v(" "),e("p",[r._v("HTML 的 "),e("code",[r._v("Content-Type")]),r._v(" 是 "),e("code",[r._v("text/html")]),r._v("，浏览器是无法直接理解 HTML 文本的。浏览器会将这一系列的字节流转换为一种有意义并且方便操作的数据结构，这种数据结构就是 "),e("code",[r._v("DOM树")]),r._v("。"),e("code",[r._v("DOM树")]),r._v(" 本质上是一个以 "),e("code",[r._v("document")]),r._v(" 为根节点的多叉树。"),e("br"),r._v("\n那浏览器是通过什么样的方式来将 HTML 语言解析成 DOM 树呢？")]),r._v(" "),e("h4",{attrs:{id:"解析算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解析算法"}},[r._v("#")]),r._v(" 解析算法")])])}),[],!1,null,null,null);t.default=v.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{432:function(_,v,t){"use strict";t.r(v);var e=t(45),o=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"外边距折叠"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#外边距折叠"}},[_._v("#")]),_._v(" 外边距折叠")]),_._v(" "),t("p",[t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing",target:"_blank",rel:"noopener noreferrer"}},[_._v("MDN 外边距折叠"),t("OutboundLink")],1)]),_._v(" "),t("p",[_._v("块元素的上外边距（margin-top）和下外边距（margin-bottom）有时合并（折叠）为单个边距，其大小为单个边距的最大值（如果相等，则仅为其中一个），这种行为称为"),t("strong",[_._v("外边距折叠")])]),_._v(" "),t("blockquote",[t("p",[_._v("注意有设定 "),t("code",[_._v("float")]),_._v(" 和 "),t("code",[_._v("position=absolute")]),_._v(" 的元素不会产生外边距重叠行为。")])]),_._v(" "),t("h2",{attrs:{id:"触发条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#触发条件"}},[_._v("#")]),_._v(" 触发条件")]),_._v(" "),t("p",[_._v("有三种情况会形成外边距折叠：")]),_._v(" "),t("h3",{attrs:{id:"同一层相邻元素之间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同一层相邻元素之间"}},[_._v("#")]),_._v(" 同一层相邻元素之间")]),_._v(" "),t("p",[_._v("相邻的两个元素之间的外边距会重叠，除非后一个元素浮动后再加上 clear-fix 清除浮动。")]),_._v(" "),t("h3",{attrs:{id:"没有将父元素和后代元素分开"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#没有将父元素和后代元素分开"}},[_._v("#")]),_._v(" 没有将父元素和后代元素分开")]),_._v(" "),t("ol",[t("li",[_._v("如果没有边框 "),t("code",[_._v("border")]),_._v("，内边距 "),t("code",[_._v("padding")]),_._v("，行内内容，也没有"),t("code",[_._v("创建块级格式上下文")]),_._v("或"),t("code",[_._v("清除浮动来")]),_._v("分开一个块级元素的上边界 "),t("code",[_._v("margin-top")]),_._v(" 与其内一个或多个后代块级元素的上边界 "),t("code",[_._v("margin-top")]),_._v("；")]),_._v(" "),t("li",[_._v("或没有边框"),t("code",[_._v("border")]),_._v("，内边距"),t("code",[_._v("padding")]),_._v("，行内内容，高度 "),t("code",[_._v("height")]),_._v("，最小高度 "),t("code",[_._v("min-height")]),_._v(" 或 最大高度 "),t("code",[_._v("max-height")]),_._v(" 来分开一个块级元素的下边界 "),t("code",[_._v("margin-bottom")]),_._v(" 与其内的一个或多个后代后代块元素的下边界 "),t("code",[_._v("margin-bottom")]),_._v(";")])]),_._v(" "),t("p",[_._v("以上 2 种情况就会出现父块元素和其内后代块元素外边界重叠，重叠部分最终会溢出到父级块元素外面。")]),_._v(" "),t("h3",{attrs:{id:"空的块级元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#空的块级元素"}},[_._v("#")]),_._v(" 空的块级元素")]),_._v(" "),t("p",[_._v("当一个块元素上边界 "),t("code",[_._v("margin-top")]),_._v(" 直接贴到元素下边界 "),t("code",[_._v("margin-bottom")]),_._v(" 时也会发生边界折叠。这种情况会发生在一个块元素完全没有设定边框 "),t("code",[_._v("border")]),_._v("、内边距 "),t("code",[_._v("paddng")]),_._v("、高度 "),t("code",[_._v("height")]),_._v("、最小高度 "),t("code",[_._v("min-height")]),_._v(" 、最大高度 "),t("code",[_._v("max-height")]),_._v("。")]),_._v(" "),t("h2",{attrs:{id:"一些需要注意的地方"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一些需要注意的地方"}},[_._v("#")]),_._v(" 一些需要注意的地方")]),_._v(" "),t("ol",[t("li",[_._v("上述情况的组合会产生更复杂的外边距折叠。")]),_._v(" "),t("li",[_._v("即使某一外边距为 0，这些规则仍然适用。因此就算父元素的外边距是 0，第一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面。")]),_._v(" "),t("li",[_._v("如果参与折叠的外边距中包含负值，折叠后的外边距的值为最大的正边距与最小的负边距（即绝对值最大的负边距）的和,；也就是说如果有-13px 8px 100px 叠在一起，边界范围的技术就是 100px -13px 的 87px。")]),_._v(" "),t("li",[_._v("如果所有参与折叠的外边距都为负，折叠后的外边距的值为最小的负边距的值。这一规则适用于相邻元素和嵌套元素。")])]),_._v(" "),t("p",[_._v("以上这些内容都是发生在 Block-Level 的元素，设定 floating 和 absolutely positioned 的元素完全不用担心边界重叠的问题。")])])}),[],!1,null,null,null);v.default=o.exports}}]);
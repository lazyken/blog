# JavaScript 代码的执行流程

⼀段 JavaScript 代码在执⾏之前需要被 JavaScript 引擎编译，编译完成之后，才会进⼊执⾏阶段。

## 编译

一段代码经过编译后会生成执行上下文(Execution Context)和可执行代码(Executable Code)

## 执行上下文

执行上下文（execution context，也称作执行环境）是 JavaScript 中最为重要的一个概念。执行上下文定义了变量或函数有权访问的其他数据，决定了它们各自的行为。执⾏上下⽂是 JavaScript 执⾏⼀段代码时的运⾏环境，⽐如调⽤⼀个函数，就会进⼊这个函数的执⾏上下⽂，确定该函数在执⾏期间⽤到的诸如 this、变量、对象以及函数等。

执行上下文一般有三种：

- 当 JavaScript 执⾏全局代码的时候，会编译全局代码并创建全局执⾏上下⽂，⽽且在整个⻚⾯的⽣存周期内，全局执⾏上下⽂只有⼀份。
- 当调⽤⼀个函数的时候，函数体内的代码会被编译，并创建函数执⾏上下⽂，⼀般情况下，函数执⾏结束之后，创建的函数执⾏上下⽂会被销毁。
- 当使⽤ eval 函数的时候，eval 的代码也会被编译，并创建执⾏上下⽂。

### 执行栈

每个函数都有自己的执行上下文。当执行流进入一个函数时，函数的执行上下文就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行上下文。ECMAScript 程序中的执行流正是由这个方便的机制控制着。  
另外要注意，调用栈(执行栈)是有大小的，当⼊栈的执⾏上下⽂超过⼀定数⽬，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。在写递归函数时就会容易出现栈溢出的情况。

```js
function foo() {
  var a = 2;
  console.log(a);
}
var a = 1;
foo();
console.log(a);
```

执行栈是一个栈结构(FILO)，对于上面的代码，全局执行上下文首先被推入执行栈；然后执行到 foo 函数时，又将 foo 的执行上下文推入执行栈，控制权转到 foo 的执行上下文；foo 函数执行完后，执行栈将 foo 的执行上下文推出执行栈，将控制权交给全局执行上下文；最后全局上下文的代码执行完后，执行栈将全局上下文推出。

## 变量环境、词法环境、变量提升

执行上下文中存在变量环境(variable Environment)和词法环境(Lexical Environment)。

### 变量环境

每个执行上下文都有一个与之关联的变量对象（variable object），执行上下文中定义通过 var 声明的变量作为一个属性保存在这个对象中并初始化属性的值为 undefined；对于函数声明，首先会在堆(HEAP)内存中创建函数，然后在变量对象中保存函数的同名属性，并将函数在堆内存的地址赋值给这个同名属性。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。

### 词法环境

和变量环境类似，执行上下文中通过 let 或 const 声明的变量会保存在词法作用域中。后面会具体说到的块级作用域即是通过词法环境来实现的。
词法环境也是一个栈结构，一个执行上下文中存在多个作用域时，词法环境中有多个区域来保存不同作用域中通过 let 或 const 定义的变量。

> 1、注意区分执行上下文和作用域，块作用域和 `try...catch` 的 `catch` 部分都会有自己的作用域，但是他们不具有新的单独的执行上下文。即在当前执行上下文中会有多个作用域，比如在一个函数执行上下文中，除了有函数的作用域，块级作用域也是在当前执行上下文范围中的。
> 2、函数只有在被执行时，才会对其内部代码进行编译，然后执行内部代码，其实这就是 js 通过执行栈控制执行流的机制。

### 变量提升

简单的说就是 js 代码在执行过程中，js 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。它是通过变量环境来实现的。

将前面的例子变一下：

```js
foo();
console.log(a);
function foo() {
  var a = 2;
  console.log(a);
}
var a = 1;
```

可以看到代码在声明变量 a 和函数 foo 之前就可以访问了。变量提升后，会给变量设置默认值 undefined，函数是直接提升，let 和 const 不能在他们声明变量之前访问，会报错，后面再详细讲。

变量提升看上去像是将变量提到了代码开头，其实不然。实际上在编译过程中，执行上下文会创建一个变量环境(即变量对象，variable object)。变量环境保存了变量提升的内容。在编译过程中，当执行到变量声明和函数声明时，对于变量，js 引擎在当前执行上下文到变量环境中创建名为 a 的属性，并对它进行初始化，赋值为 undefined；对于函数声明，首先会在堆(HEAP)内存中创建函数，然后在当前执行上下文到变量环境中创建名为 foo 的属性，foo 的值为刚才在堆内存中创建的函数的地址。

## 作用域和作用域链

当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行上下文有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行上下文；全局执行上下文的变量对象始终都是作用域链中的最后一个对象。

标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。

某个执行上下文中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行上下文直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。

### 区分执行上下文和作用域

执行上下文是运行时产生并保存在栈结构中。
作用域即是词法作用域，有全局作用域，函数作用域和块作用域，它在编译时的词法分析阶段就确定了，和函数怎么调用没关系。

先编译，生成全局上下文和全局作用域，执行函数时再编译函数代码生成函数执行上下文和函数作用域，然后执行函数把函数执行上下文推入执行栈，函数执行上下文变为活动的执行上下文

### 块级作用域

当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包 含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的 其中一个属性，会在函数执行的过程中用到。

在渲染引擎内部，有⼀个叫 HHTTMMLL 解解析析器器（（HHTTMMLLPPaarrsseerr））的模块，它的职责就是负责将 HTML 字节流转换 为 DOM 结构。

⽹络进程加载了多少数据，HTML 解析器便解析多少数据。

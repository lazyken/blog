函数节流和函数防抖都是「闭包」、「高阶函数」的应用，他们的目的都是优化短时间内同一函数频繁被调用的场景。比如页面滚动时执行某个函数，可以使用节流函数来降低函数被触发等频次，input 输入可以使用防抖函数，只在用户输入结束时执行函数等...

# 节流

## 定义

函数节流指的是在一定时间间隔内（例如 3 秒）某个函数被重复调用时只执行一次，在这 3 秒内无视后来产生的函数调用请求。

## 实现思路

第一种：用时间戳来判断是否已到执行时间，记录上次执行的时间戳，然后每次触发事件执行回调，回调中判断当前时间戳距离上次执行时间戳的间隔是否已经达到时间差，如果是则执行，并更新上次执行的时间戳，如此循环。
第二种：使用定时器，函数第一次被调用时设置一个定时器 `timer=setTimeout()`，此后每次重复触发函数，判断如果已经存在定时器，则直接 `return`；直到定时器触发，清除定时器 `timer`。之后函数再次执行时此时 `timer` 为 `null`，则可以重新设置定时器。

## 手写

```js
const throttle = function (fn, wait = 50) {
  var prev = 0; // 初始时间值为0，第一次始终立即执行
  return function (...argus) {
    var now = new Date().getTime();
    if (now - prev > wait) {
      prev = now;
      fn.apply(this, argus);
    }
  };
};
```

# 防抖

防抖函数 `debounce` 被设计为：连续多次调用函数时，相邻的两次函数调用需要间隔超过指定的时间才能执行，否则不执行。

## 思路

实现原理就是利用定时器，函数第一次执行时设定一个定时器，之后调用时发现已经设定过定时器就清空之前的定时器，并重新设定一个新的定时器，如果存在没有被清空的定时器，当定时器计时结束后触发函数执行。

## 手写

```js
const debounce = function (fn, wait = 50, immediate) {
  var timer = null;
  return function (...argus) {
    // 每次调用都重置定时器，不管上一次计时是否结束都适用
    // 定时器执行完后会自动清理，再手动清理，没有什么效果也不会报错
    if (timer) {
      clearTimeout(timer);
    }
    // 第一次触发时立即执行一次
    // 这个第一次包括首次及之后超过时间间隔的
    if (immediate && !timer) {
      fn.call(this, argus);
    }
    timer = setTimeout(function () {
      fn.call(this, argus);
    }, wait);
  };
};
```
